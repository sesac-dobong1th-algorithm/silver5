"""
저는 백준 입력부터 보고가야지 상황을 이해하기 편하더라구요 입력부터 먼저 정의하겠습니다.

입력을 보자
입력의 첫 번째 줄은 테스트 케이스 수, T. T 줄이 이어집니다. 각 줄에는 공백으로 구분된 실수 세 개가 들어 있습니다:
C, F, X가 포함되며, 그 의미는 문제 설명의 앞부분에 설명되어 있습니다.

C, F, X는 각각 최소 1자리와 소수점 이하 1자리, 1~5자리로 구성됩니다. 선행 0은 없습니다.

제한값

1 ≤ T ≤ 100.
1 ≤ C ≤ 10000.
1 ≤ F ≤ 100.
1 ≤ X ≤ 100000.

세상에 입력 예시 안보면 이해하기 너무 힘들었습니다 다들 잘 이해하신것 같던데..

입력
4   <= 테스트 케이스의 개수 T
30.0 1.0 2.0 <= C=30.0, F=1.0, X=2.0
30.0 2.0 100.0  <= C=30.0, F=2.0, X=100.0
30.50000 3.14159 1999.19990 <= C=30.5, F=3.14159, X=1999.19990
500.0 4.0 2000.0 <=  C=500.0, F=4.0, X=2000.0

문제가 길지만 1번부터 순서대로 상황을 정리해서 알려주고있네요
C(농장구매시필요양) F(농장구매시 쿠키생산률) X(농장구매하고 목표)를 받음

C=500.0, F=4.0, X=2000.0이라고 가정합니다. 최상의 전략은 다음과 같습니다:
1.0개의 쿠키로 시작하지만 초당 2개의 쿠키를 생산합니다.
2.250초 후에는 C=500 쿠키를 갖게 되며, 초당 F=4 쿠키를 생산하는 농장을 구매할 수 있습니다. (여기서 X/C)
3. 농장을 구입한 후에는 쿠키가 0개이며, 총 쿠키 생산량은 초당 6개입니다.                   (기존생산량과 F를 더해서 생산률이 올라감)
4. 다음 농장의 가격은 500쿠키이며, 약 83.3333333초 후에 구매할 수 있습니다.                (500/6.0)
5. 두 번째 농장을 구입한 후에는 쿠키가 0개이며, 총 쿠키 생산량은 초당 10개입니다.          (생산량 10됨)
6.또 다른 농장은 500 쿠키가 필요하며, 50초 후에 구입할 수 있습니다.                        (500/10)
7.세 번째 농장을 구입한 후 쿠키가 0개이고 총 쿠키 생산량은 초당 14개입니다.                (F가 4임으로 생샌량도 4씩오름 14)
8.또 다른 농장은 500개의 쿠키가 필요하지만 실제로는 구매하지 않는 것이 좋습니다.
대신 X=2000개의 쿠키가 생길 때까지 기다리면 되는데, 약 142.8571429초가 걸립니다.
(왜냐면 현재 생산률료만 목표해 도달하는것이 142.8571429
농장을 구매하고 기다리는 것 보다 빠르다면=>(500/14)+(2000/18) = 111.1111+35.714=146.7142857

총 시간: 250 + 83.3333333 + 50 + 142.8571429 = 526.1904762초.

핵심은 공장까지 걸리는 초를 구하다가
마지막에 (목표 / 현재 생산량) >= (농장/현재생산량) + (목표/개선된생산량) 라면
모두 더하면 되는식... 세상... 오래걸렸네요

값 입력받았을때 
목표값 = 


"""

def time_to_win(C, F, X):
    current_rate = 2.0  # 초기 생산률은 2.0
    time = 0.0  # 경과 시간 초기화
    farms = 0  # 구매한 농장 개수 초기화

    while True:
        # 현재 생산률로 X(목표)까지 도달하는데 걸리는 시간 계산
        time_without_farm = X / current_rate

        # 다음 농장을 구매하는데 걸리는 시간 계산
        time_to_buy_farm = C / current_rate

        # 새로운 농장을 구매한 후 X까지 도달하는데 걸리는 시간 계산
        time_with_farm = time_to_buy_farm + X / (current_rate + F)

        # 현재 생산률로 바로 X까지 도달하는 것이 농장을 구매하고 기다리는 것보다 빠르면 반환
        if time_without_farm <= time_with_farm:
            return time + time_without_farm

        # 농장 구매 누적해야 계산이 됩니다.
        time += time_to_buy_farm
        current_rate += F
        farms += 1

def cookie_clicker(test_cases):
    # 패킹으로 리스트로 반환
    results = [time_to_win(*case) for case in test_cases]
    return results

# 테스트 케이스 개수 입력
T = int(input())

# 테스트 케이스 입력
test_cases = [tuple(map(float, input().split())) for _ in range(T)]

# 결과 출력
for i, result in enumerate(cookie_clicker(test_cases)):
    print(f"Case #{i + 1}: {result:.7f}")  # 결과를 소수점 7자리까지 출력
